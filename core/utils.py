import os
import gspread
import pandas as pd
from datetime import datetime, timedelta
from channels.layers import get_channel_layer
from asgiref.sync import async_to_sync
from datetime import timedelta as dt_timedelta
# from django.db import transaction
# from django.utils import timezone as dj_timezone
# from .models import Profile, Notificacao, RegistroNotificacao
# from solicitacao_almox.models import SolicitacaoRequisicao, SolicitacaoTransferencia

# Constantes de alerta
# LIMITE_ERROS = 20
# FREQUENCIA_ALERTA_ERROS = dt_timedelta(days=2)  # ajuste conforme desejado
# CACHE_DF = None 
# CACHE_EXPIRATION_TIME = datetime.min 
# CACHE_DURATION = timedelta(hours=24) 

def notificar_ordem(ordem):
    channel_layer = get_channel_layer()
    async_to_sync(channel_layer.group_send)(
        "ordens_iniciadas",
        {
            "type": "enviar_ordem",
            "data": {
                "ordem": ordem.ordem,
                "ultima_atualizacao": ordem.ultima_atualizacao.isoformat()
            }
        }
    )

# def notificacao_almoxarifado(
#     titulo: str,
#     mensagem: str,
#     rota_acesso: str,
#     tipo: str = "info",
#     chave: str = None,
#     frequencia: dt_timedelta = None,
# ):
#     # 1) Controle de frequ√™ncia
#     if chave and frequencia:
#         agora = dj_timezone.now()
#         try:
#             registro = RegistroNotificacao.objects.get(chave=chave)
#             if agora - registro.ultimo_envio < frequencia:
#                 print(f"üîï Notifica√ß√£o para a chave '{chave}' pulada.")
#                 return
#         except RegistroNotificacao.DoesNotExist:
#             pass
#     elif chave or frequencia:
#         raise ValueError("Para notifica√ß√µes peri√≥dicas, 'chave' e 'frequencia' devem ser fornecidos.")

#     profiles_to_notify = Profile.objects.filter(tipo_acesso="almoxarifado")
#     if not profiles_to_notify.exists():
#         print("AVISO: Nenhum usu√°rio com perfil de destino foi encontrado.")
#         return

#     # 2) Escritas em transa√ß√£o
#     try:
#         with transaction.atomic():
#             notificacoes_criadas = 0
#             for profile in profiles_to_notify:
#                 Notificacao.objects.create(
#                     profile=profile,
#                     rota_acesso=rota_acesso,
#                     titulo=titulo,
#                     mensagem=mensagem,
#                     tipo=tipo,
#                 )
#                 notificacoes_criadas += 1

#             if chave:
#                 RegistroNotificacao.objects.update_or_create(
#                     chave=chave,
#                     defaults={"ultimo_envio": dj_timezone.now()},
#                 )

#             if notificacoes_criadas > 0:
#                 print(f"‚úÖ Transa√ß√£o conclu√≠da: {notificacoes_criadas} notifica√ß√µes criadas com sucesso.")
#     except Exception as e:
#         print(f"‚ùå ERRO na transa√ß√£o ao criar notifica√ß√µes: {e}. Rollback executado.")

# def verificar_e_notificar_requisicoes_pendentes():
#     """
#     Verifica o n√∫mero total de requisi√ß√µes pendentes e envia uma notifica√ß√£o
#     se o limite de 30 for atingido.
#     Usa um controle de frequ√™ncia para n√£o enviar m√∫ltiplos alertas seguidos.
#     """
#     requisicoes_pendentes = SolicitacaoRequisicao.objects.filter(
#         entregue_por__isnull=True, data_entrega__isnull=True
#     ).count()

#     if requisicoes_pendentes >= 30:
#         print(f"‚ö†Ô∏è Limite atingido! {requisicoes_pendentes} requisi√ß√µes pendentes. Tentando notificar...")

#         notificacao_almoxarifado(
#             titulo="Alerta: Alto Volume de Requisi√ß√µes",
#             mensagem=f"Existem {requisicoes_pendentes} requisi√ß√µes pendentes de atendimento. Por favor, verifique.",
#             rota_acesso="/almox/solicitacoes-page/",
#             tipo="aviso",
#             chave="alerta_requisicoes_pendentes_almox",
#             frequencia=dt_timedelta(days=2),  # ajuste aqui
#         )


# def verificar_e_notificar_transferencias_pendentes():
#     """
#     Verifica o n√∫mero total de transfer√™ncias pendentes e envia uma notifica√ß√£o
#     se o limite de 30 for atingido.
#     Usa um controle de frequ√™ncia para n√£o enviar m√∫ltiplos alertas seguidos.
#     """
#     transferencias_pendentes = SolicitacaoTransferencia.objects.filter(
#         entregue_por__isnull=True, data_entrega__isnull=True
#     ).count()

#     if transferencias_pendentes >= 30:
#         print(f"‚ö†Ô∏è Limite atingido! {transferencias_pendentes} transfer√™ncias pendentes. Tentando notificar...")

#         notificacao_almoxarifado(
#             titulo="Alerta: Alto Volume de Transfer√™ncias",
#             mensagem=f"Existem {transferencias_pendentes} requisi√ß√µes pendentes de atendimento. Por favor, verifique.",
#             rota_acesso="/almox/solicitacoes-page/",
#             tipo="alerta",
#             chave="alerta_transferencias_pendentes_almox",
#             frequencia=dt_timedelta(days=2),  # ajuste aqui
#         )

# def contar_erros_requisicoes() -> int:
#     # rpa diferente de 'OK' (case-insensitive), desconsiderando nulos e vazios
#     return (
#         SolicitacaoRequisicao.objects
#         .filter(rpa__isnull=False)
#         .exclude(rpa__iexact="OK")
#         .exclude(rpa__exact="")
#         .count()
#     )

# def contar_erros_transferencias() -> int:
#     return (
#         SolicitacaoTransferencia.objects
#         .filter(rpa__isnull=False)
#         .exclude(rpa__iexact="OK")
#         .exclude(rpa__exact="")
#         .count()
#     )

# def notificar_erro_requisicoes_se_acima_limite():
#     qtd = contar_erros_requisicoes()
#     if qtd > LIMITE_ERROS:
#         notificacao_almoxarifado(
#             titulo="Alerta: Requisi√ß√µes com erro",
#             mensagem=f"Existem {qtd} requisi√ß√µes com erro. Verifique o painel do Almox.",
#             rota_acesso="/almox/erros/",
#             tipo="aviso",
#             chave="alerta_erros_requisicoes_almox",
#             frequencia=FREQUENCIA_ALERTA_ERROS,
#         )

# def notificar_erro_transferencias_se_acima_limite():
#     qtd = contar_erros_transferencias()
#     if qtd > LIMITE_ERROS:
#         notificacao_almoxarifado(
#             titulo="Alerta: Transfer√™ncias com erro",
#             mensagem=f"Existem {qtd} transfer√™ncias com erro. Verifique o painel do Almox.",
#             rota_acesso="/almox/erros/",
#             tipo="aviso",
#             chave="alerta_erros_transferencias_almox",
#             frequencia=FREQUENCIA_ALERTA_ERROS,
#         )

def format_private_key(key):
    """
    Substitui as ocorr√™ncias literais de '\\n' na chave privada 
    por quebras de linha reais.
    """
    if key:
        return key.replace('\\n', '\n')
    return key

# --- Constru√ß√£o do Objeto de Credenciais ---
def get_google_credentials():
    """
    Carrega e formata o objeto de credenciais a partir das vari√°veis de ambiente.
    """
    credentials_google = {
        "type": os.environ.get('type'),
        "project_id": os.environ.get('project_id'),
        "private_key": format_private_key(os.environ.get('private_key')),
        "client_email": os.environ.get('client_email'),
        "client_id": os.environ.get('client_id'),
        "auth_uri": os.environ.get('auth_uri'),
        "token_uri": os.environ.get('token_uri'),
        "auth_provider_x509_cert_url": os.environ.get('auth_provider_x509_cert_url'),
        "client_x509_cert_url": os.environ.get('client_x509_cert_url'),
        "universe_domain": os.environ.get('universe_domain')
    }
    
    if not credentials_google.get('private_key') or not credentials_google.get('client_email'):
        print("Erro: Credenciais essenciais (PRIVATE_KEY ou CLIENT_EMAIL) n√£o encontradas nas vari√°veis de ambiente.")
        return None
        
    return credentials_google

# ----------------------------------------

def carregar_planilha_base_geral():
    """
    Carrega os dados da planilha base geral, lidando com colunas duplicadas
    e utilizando cache di√°rio.
    """
    global CACHE_DF, CACHE_EXPIRATION_TIME

    # 1. VERIFICA√á√ÉO DO CACHE (Permanece inalterada)
    if CACHE_DF is not None and datetime.now() < CACHE_EXPIRATION_TIME:
        print("Cache di√°rio v√°lido. Utilizando dados em mem√≥ria.")
        return CACHE_DF
    
    print("Cache expirado ou vazio. Recarregando planilha do Google Sheets...")

    chave_planilha = os.environ.get('BASE_GERAL_KEY')
    credentials = get_google_credentials()
    if not chave_planilha or credentials is None:
        return None

    try:
        gc = gspread.service_account_from_dict(credentials)
        sh = gc.open_by_key(chave_planilha)
        worksheet = sh.worksheet("BASE ATUALIZADA") 
        
        data = worksheet.get_all_values()

        if not data:
            print("Planilha vazia.")
            return None

        headers = data[0]
        records = data[1:]

        colunas_interesse = ['CODIGO', 'DESCRI√á√ÉO', 'CONJUNTO', '2 PROCESSO']
        
        indices_para_manter = []
        headers_filtrados = []
        
        for i, header in enumerate(headers):
            if header in colunas_interesse and header not in headers_filtrados:
                indices_para_manter.append(i)
                headers_filtrados.append(header)

        dados_filtrados = [
            [row[i] for i in indices_para_manter] 
            for row in records
        ]
        
        df = pd.DataFrame(dados_filtrados, columns=headers_filtrados)

        df['CONJUNTO_CODIGO_PURO'] = df['CONJUNTO'].str.split(' - ').str[0].str.strip()

        df['DESCRI√á√ÉO'] = df['CONJUNTO'].str.split(' - ').str[1].str.strip()
        
        df['CONJUNTO_CODIGO_PURO'].fillna(df['CONJUNTO'], inplace=True)

        df_filtrado = df.astype(str)

        CACHE_DF = df_filtrado
        CACHE_EXPIRATION_TIME = datetime.now() + CACHE_DURATION
        print(f"Planilha carregada ({len(df_filtrado)} registros). Novo cache expira em: {CACHE_EXPIRATION_TIME.strftime('%Y-%m-%d %H:%M:%S')}")

        return CACHE_DF

    except Exception as e:
        print(f"Erro ao carregar a planilha. Erro: {e}")
        return CACHE_DF if CACHE_DF is not None else None
